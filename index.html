<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MINOOTS - Distributed Horology Platform</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --cyan: #00ffff;
            --magenta: #ff00ff;
            --blue: #0080ff;
            --green: #00ff80;
            --font-display: 'Orbitron', sans-serif;
            --font-body: 'Inter', system-ui, sans-serif;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000000;
        }

        body {
            font-family: var(--font-body);
            color: #ffffff;
            -webkit-font-smoothing: antialiased;
        }

        /* VIB3+ Quantum Visualizer - FIXED BACKGROUND */
        .quantum-layers {
            position: fixed;
            inset: 0;
            z-index: 0;
            pointer-events: none;
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            will-change: transform;
        }

        .quantum-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            mix-blend-mode: screen;
        }

        #quantum-background { opacity: 0.3; z-index: 1; }
        #quantum-shadow { opacity: 0.2; z-index: 2; mix-blend-mode: multiply; }
        #quantum-content { opacity: 0.6; z-index: 3; }
        #quantum-highlight { opacity: 0.4; z-index: 4; }
        #quantum-accent { opacity: 0.25; z-index: 5; }

        /* CONTENT CONTAINER - ALWAYS CENTERED */
        #content-container {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .content-wrapper {
            max-width: 1200px;
            width: 100%;
            padding: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* CARD CHOREOGRAPHY SYSTEM */
        .card-stage {
            position: relative;
            width: 100%;
            max-width: 1200px;
            height: 600px;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            gap: 40px;
            perspective: 2000px;
            transform-style: preserve-3d;
        }

        .morph-card {
            position: relative;
            padding: 60px 50px;
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow:
                0 0 60px rgba(0, 255, 255, 0.2),
                inset 0 0 40px rgba(0, 255, 255, 0.05);
            transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-style: preserve-3d;
            will-change: transform, opacity, border-radius;
            overflow: hidden;
        }

        /* Card States for Splitting */
        .card-stage.split-2 {
            grid-template-columns: 1fr 1fr;
        }

        .card-stage.split-3 {
            grid-template-columns: repeat(3, 1fr);
        }

        .card-stage.split-4 {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
        }

        .morph-card.card-clone {
            opacity: 0;
            transform: scale(0.8) rotateY(-20deg);
        }

        .morph-card.card-clone.active {
            opacity: 1;
            transform: scale(1) rotateY(0deg);
        }

        /* Card background accent */
        .card-bg-accent {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at var(--accent-x, 50%) var(--accent-y, 50%),
                        rgba(0, 255, 255, 0.1) 0%, transparent 60%);
            opacity: 0;
            transition: opacity 0.8s ease;
            pointer-events: none;
        }

        /* TYPOGRAPHY */
        h1 {
            font-family: var(--font-display);
            font-size: clamp(3rem, 7vw, 6rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 30px;
            background: linear-gradient(135deg, var(--cyan), var(--magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            opacity: 0;
            transform: translateY(60px) scale(0.8);
            transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        h2 {
            font-family: var(--font-display);
            font-size: clamp(2.5rem, 5vw, 4.5rem);
            font-weight: 700;
            margin-bottom: 24px;
            color: var(--cyan);
            opacity: 0;
            transform: translateY(50px) scale(0.85);
            transition: all 1.1s cubic-bezier(0.34, 1.56, 0.64, 1) 0.1s;
        }

        .subtitle {
            font-size: clamp(1.3rem, 2.5vw, 2rem);
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 40px;
            opacity: 0;
            transform: translateY(40px) translateX(-20px);
            transition: all 1s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s;
        }

        .body-text {
            font-size: clamp(1.1rem, 1.8vw, 1.5rem);
            line-height: 1.9;
            color: rgba(255, 255, 255, 0.75);
            margin-bottom: 30px;
            opacity: 0;
            transform: translateY(30px) translateX(20px);
            transition: all 0.9s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s;
        }

        /* ACTIVE STATE - Show all elements */
        .active h1 {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .active h2 {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .active .subtitle {
            opacity: 1;
            transform: translateY(0) translateX(0);
        }

        .active .body-text {
            opacity: 1;
            transform: translateY(0) translateX(0);
        }

        .active .card-bg-accent {
            opacity: 1;
        }

        /* STATS GRID */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 30px;
            margin-top: 50px;
        }

        .stat-card {
            padding: 30px;
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 20px;
            text-align: center;
            opacity: 0;
            transform: translateY(40px) rotateX(-15deg);
            transition: all 1s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .active .stat-card:nth-child(1) { transition-delay: 0.4s; }
        .active .stat-card:nth-child(2) { transition-delay: 0.5s; }
        .active .stat-card:nth-child(3) { transition-delay: 0.6s; }

        .active .stat-card {
            opacity: 1;
            transform: translateY(0) rotateX(0);
        }

        .stat-number {
            font-family: var(--font-display);
            font-size: 3.5rem;
            font-weight: 900;
            color: var(--cyan);
            margin-bottom: 10px;
        }

        .stat-label {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.6);
        }

        /* ACCENT TEXT */
        .accent { color: var(--cyan); font-weight: 700; }
        .highlight { color: var(--magenta); font-weight: 700; }

        /* SCROLL INDICATOR */
        .scroll-indicator {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .scroll-indicator.hidden {
            opacity: 0;
        }

        .scroll-text {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(0, 255, 255, 0.6);
        }

        .scroll-arrow {
            width: 24px;
            height: 40px;
            border: 2px solid var(--cyan);
            border-radius: 12px;
            position: relative;
        }

        .scroll-arrow::after {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 8px;
            background: var(--cyan);
            border-radius: 2px;
            animation: scrollDot 2s ease infinite;
        }

        @keyframes scrollDot {
            0%, 100% { opacity: 1; transform: translateX(-50%) translateY(0); }
            50% { opacity: 0.3; transform: translateX(-50%) translateY(16px); }
        }

        /* PROGRESS DOTS */
        .progress-dots {
            position: fixed;
            right: 40px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 255, 0.3);
            background: transparent;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .progress-dot.active {
            background: var(--cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transform: scale(1.5);
        }

        /* TICK DEBUG */
        .tick-debug {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            padding: 16px 22px;
            border-radius: 12px;
            border: 1px solid var(--cyan);
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            color: var(--cyan);
        }

        .tick-debug span {
            display: block;
            margin: 5px 0;
        }

        .tick-debug strong {
            color: var(--magenta);
        }
    </style>
</head>
<body>
    <!-- VIB3+ Quantum Visualizer -->
    <div class="quantum-layers" id="quantum-layers">
        <canvas id="quantum-background" class="quantum-canvas"></canvas>
        <canvas id="quantum-shadow" class="quantum-canvas"></canvas>
        <canvas id="quantum-content" class="quantum-canvas"></canvas>
        <canvas id="quantum-highlight" class="quantum-canvas"></canvas>
        <canvas id="quantum-accent" class="quantum-canvas"></canvas>
    </div>

    <!-- Content Container - Always Centered -->
    <div id="content-container">
        <div class="content-wrapper">
            <div class="card-stage" id="card-stage">
                <div class="morph-card active" id="morph-card">
                    <div class="card-bg-accent"></div>
                    <div id="section-content">
                        <!-- Content injected by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- UI Elements -->
    <div class="scroll-indicator" id="scroll-indicator">
        <span class="scroll-text">Scroll to Explore</span>
        <div class="scroll-arrow"></div>
    </div>

    <div class="progress-dots" id="progress-dots"></div>

    <div class="tick-debug">
        <span>Section: <strong id="debug-section">0</strong></span>
        <span>Ticks: <strong id="debug-ticks">0 / 5</strong></span>
        <span>Vis Offset: <strong id="debug-offset">0</strong></span>
        <span>Density: <strong id="debug-density">40</strong></span>
        <span>Rot4dXW: <strong id="debug-rot">0.00</strong></span>
    </div>

    <script type="module">
        // ========== SECTION DEFINITIONS WITH COMPLETE VIB3+ ORCHESTRATION ==========
        const SECTIONS = [
            {
                id: 0,
                content: `
                    <h1>MINOOTS</h1>
                    <div class="subtitle">What if time itself could be autonomous?</div>
                `,
                // CARD CHOREOGRAPHY
                cards: {
                    count: 1, // Single card for intro
                    splitAnimation: 'fade-scale'
                },
                // COMPLETE 17+ PARAMETER SYSTEM PER LAYER
                layers: {
                    background: {
                        geometry: 1, // Hypersphere
                        gridDensity: 8.0,
                        morphFactor: 0.3,
                        dimension: 3.5,
                        rotationSpeed: 0.2,
                        lineThickness: 0.015,
                        patternIntensity: 0.4,
                        universeModifier: 0.8,
                        glitchIntensity: 0.0,
                        colorShift: 0.0,
                        rot4dXW: 0.0,
                        rot4dYW: 0.0,
                        rot4dZW: 0.0,
                        offsetY: 0.0
                    },
                    shadow: {
                        geometry: 1,
                        gridDensity: 10.0,
                        morphFactor: 0.4,
                        dimension: 3.6,
                        rotationSpeed: 0.3,
                        lineThickness: 0.02,
                        patternIntensity: 0.5,
                        universeModifier: 0.9,
                        glitchIntensity: 0.02,
                        colorShift: 0.1
                    },
                    content: {
                        geometry: 1,
                        gridDensity: 12.0,
                        morphFactor: 0.5,
                        dimension: 3.8,
                        rotationSpeed: 0.4,
                        lineThickness: 0.025,
                        patternIntensity: 0.7,
                        universeModifier: 1.0,
                        glitchIntensity: 0.03,
                        colorShift: 0.0
                    },
                    highlight: {
                        geometry: 1,
                        gridDensity: 15.0,
                        morphFactor: 0.7,
                        dimension: 4.0,
                        rotationSpeed: 0.6,
                        lineThickness: 0.03,
                        patternIntensity: 0.9,
                        universeModifier: 1.2,
                        glitchIntensity: 0.05,
                        colorShift: 0.2
                    },
                    accent: {
                        geometry: 1,
                        gridDensity: 18.0,
                        morphFactor: 0.9,
                        dimension: 4.2,
                        rotationSpeed: 0.8,
                        lineThickness: 0.035,
                        patternIntensity: 1.1,
                        universeModifier: 1.4,
                        glitchIntensity: 0.08,
                        colorShift: -0.3
                    }
                },
                // ELEMENT TAKEOVER CONFIGURATION
                elementTakeover: {
                    enabled: false,
                    blendMode: 'screen',
                    intensity: 0.0
                },
                cardStyle: {
                    borderRadius: '50%',
                    aspectRatio: '1',
                    maxWidth: '650px',
                    '--accent-x': '30%',
                    '--accent-y': '40%'
                }
            },
            {
                id: 1,
                content: `
                    <h2>Distributed Horology</h2>
                    <div class="subtitle">for the Autonomous Future</div>
                    <p class="body-text">
                        MINOOTS is not just another timer system. It's a <span class="accent">distributed horology platform</span>
                        that enables <span class="highlight">50M+ concurrent timers</span> with ±50ms precision and 99.99% uptime.
                    </p>
                `,
                // CARD SPLITS INTO 2
                cards: {
                    count: 2,
                    splitAnimation: 'slide-split',
                    contents: [
                        `<h2>Distributed</h2><p class="body-text">50M+ concurrent timers</p>`,
                        `<h2>Horology</h2><p class="body-text">±50ms precision</p>`
                    ]
                },
                // UNIQUE PARAMETERS PER LAYER WITH TORUS GEOMETRY
                layers: {
                    background: {
                        geometry: 2, // Torus
                        gridDensity: 6.0,
                        morphFactor: 0.4,
                        dimension: 3.6,
                        rotationSpeed: 0.3,
                        lineThickness: 0.018,
                        patternIntensity: 0.5,
                        universeModifier: 1.0,
                        glitchIntensity: 0.02,
                        colorShift: 0.15,
                        rot4dXW: 0.2,
                        rot4dYW: 0.15,
                        rot4dZW: 0.1
                    },
                    shadow: {
                        geometry: 2,
                        gridDensity: 9.0,
                        morphFactor: 0.6,
                        dimension: 3.8,
                        rotationSpeed: 0.45,
                        lineThickness: 0.022,
                        patternIntensity: 0.65,
                        universeModifier: 1.1,
                        glitchIntensity: 0.04,
                        colorShift: 0.2
                    },
                    content: {
                        geometry: 2,
                        gridDensity: 12.0,
                        morphFactor: 0.8,
                        dimension: 4.0,
                        rotationSpeed: 0.6,
                        lineThickness: 0.028,
                        patternIntensity: 0.85,
                        universeModifier: 1.3,
                        glitchIntensity: 0.06,
                        colorShift: 0.1
                    },
                    highlight: {
                        geometry: 2,
                        gridDensity: 16.0,
                        morphFactor: 1.0,
                        dimension: 4.3,
                        rotationSpeed: 0.8,
                        lineThickness: 0.032,
                        patternIntensity: 1.1,
                        universeModifier: 1.5,
                        glitchIntensity: 0.09,
                        colorShift: -0.2
                    },
                    accent: {
                        geometry: 2,
                        gridDensity: 20.0,
                        morphFactor: 1.2,
                        dimension: 4.5,
                        rotationSpeed: 1.1,
                        lineThickness: 0.038,
                        patternIntensity: 1.4,
                        universeModifier: 1.8,
                        glitchIntensity: 0.12,
                        colorShift: 0.4
                    }
                },
                // ELEMENT TAKEOVER BEGINS
                elementTakeover: {
                    enabled: true,
                    blendMode: 'screen',
                    intensity: 0.2,
                    particleCount: 50
                },
                cardStyle: {
                    borderRadius: '120px',
                    aspectRatio: '16/10',
                    maxWidth: '750px',
                    '--accent-x': '70%',
                    '--accent-y': '30%'
                }
            },
            {
                id: 2,
                content: `
                    <h2>The Agentic Challenge</h2>
                    <p class="body-text">
                        AI agents need <span class="accent">persistent timers</span> that survive restarts,
                        scale to millions of instances, and fire with <span class="highlight">millisecond precision</span>.
                    </p>
                    <p class="body-text">
                        Traditional systems fail at scale. MINOOTS thrives.
                    </p>
                `,
                visualizer: {
                    geometry: 3,
                    baseDensity: 30,
                    baseRot4dXW: 1.0,
                    baseRot4dYW: 0.7,
                    baseRot4dZW: 0.5,
                    chaos: 0.3,
                    speed: 1.2,
                    intensity: 0.7,
                    hue: 0.65 // Cyan-magenta
                },
                cardStyle: {
                    borderRadius: '80px',
                    aspectRatio: '16/9',
                    maxWidth: '850px',
                    '--accent-x': '50%',
                    '--accent-y': '60%'
                }
            },
            {
                id: 3,
                content: `
                    <h2>Battle-Tested Architecture</h2>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-number">50M+</div>
                            <div class="stat-label">Concurrent Timers</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">±50ms</div>
                            <div class="stat-label">Precision</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">99.99%</div>
                            <div class="stat-label">Uptime SLA</div>
                        </div>
                    </div>
                `,
                visualizer: {
                    geometry: 7,
                    baseDensity: 25,
                    baseRot4dXW: 1.5,
                    baseRot4dYW: 1.2,
                    baseRot4dZW: 0.8,
                    chaos: 0.4,
                    speed: 1.4,
                    intensity: 0.8,
                    hue: 0.7 // Magenta
                },
                cardStyle: {
                    borderRadius: '60px',
                    aspectRatio: 'auto',
                    maxWidth: '900px',
                    '--accent-x': '40%',
                    '--accent-y': '50%'
                }
            },
            {
                id: 4,
                content: `
                    <h2>Powered by <span class="accent">Rust</span></h2>
                    <p class="body-text">
                        Horology Kernel: <span class="highlight">Tokio async runtime</span> + PostgreSQL + Raft consensus
                    </p>
                    <p class="body-text">
                        Event Fabric: <span class="accent">NATS JetStream</span> + Kafka + Dead Letter Queues
                    </p>
                `,
                visualizer: {
                    geometry: 7,
                    baseDensity: 22,
                    baseRot4dXW: 2.0,
                    baseRot4dYW: 1.5,
                    baseRot4dZW: 1.0,
                    chaos: 0.3,
                    speed: 1.1,
                    intensity: 0.7,
                    hue: 0.75 // Magenta-red
                },
                cardStyle: {
                    borderRadius: '50px',
                    aspectRatio: 'auto',
                    maxWidth: '850px',
                    '--accent-x': '60%',
                    '--accent-y': '40%'
                }
            },
            {
                id: 5,
                content: `
                    <h2>Universal Integration</h2>
                    <p class="body-text">
                        <span class="accent">Node.js SDK</span> • Python Client • MCP Tools • CLI
                    </p>
                    <p class="body-text">
                        Works with: <span class="highlight">LangChain • AutoGen • LlamaIndex • Slack • Discord</span>
                    </p>
                `,
                visualizer: {
                    geometry: 10,
                    baseDensity: 20,
                    baseRot4dXW: 2.5,
                    baseRot4dYW: 2.0,
                    baseRot4dZW: 1.5,
                    chaos: 0.5,
                    speed: 1.3,
                    intensity: 0.75,
                    hue: 0.8 // Purple
                },
                cardStyle: {
                    borderRadius: '50px',
                    aspectRatio: 'auto',
                    maxWidth: '850px',
                    '--accent-x': '35%',
                    '--accent-y': '55%'
                }
            },
            {
                id: 6,
                content: `
                    <h1>Time is <span class="accent">Autonomous</span></h1>
                    <p class="body-text">
                        Join the revolution at <span class="highlight">api-m3waemr5lq-uc.a.run.app</span>
                    </p>
                `,
                visualizer: {
                    geometry: 15,
                    baseDensity: 18,
                    baseRot4dXW: 3.0,
                    baseRot4dYW: 2.5,
                    baseRot4dZW: 2.0,
                    chaos: 0.6,
                    speed: 1.6,
                    intensity: 0.9,
                    hue: 0.85 // Magenta-purple
                },
                cardStyle: {
                    borderRadius: '40px',
                    aspectRatio: 'auto',
                    maxWidth: '900px',
                    '--accent-x': '50%',
                    '--accent-y': '50%'
                }
            }
        ];

        // ========== VIB3+ QUANTUM VISUALIZER ==========
        class QuantumVisualizer {
            constructor(canvasId, role, reactivity) {
                this.canvas = document.getElementById(canvasId);
                this.role = role;
                this.reactivity = reactivity;

                this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                if (!this.gl) return;

                this.startTime = Date.now();
                this.params = {
                    geometry: 1,
                    gridDensity: 40,
                    morphFactor: 1.0,
                    chaos: 0.2,
                    speed: 1.0,
                    hue: 0.556,
                    intensity: 0.5,
                    saturation: 0.8,
                    dimension: 3.5,
                    rot4dXW: 0.0,
                    rot4dYW: 0.0,
                    rot4dZW: 0.0,
                    offsetY: 0.0
                };

                this.init();
            }

            init() {
                this.initShaders();
                this.initBuffers();
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            initShaders() {
                const vertexShader = `
                    attribute vec2 a_position;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;

                const fragmentShader = `
                    #ifdef GL_FRAGMENT_PRECISION_HIGH
                        precision highp float;
                    #else
                        precision mediump float;
                    #endif

                    uniform vec2 u_resolution;
                    uniform float u_time;
                    uniform float u_geometry;
                    uniform float u_gridDensity;
                    uniform float u_chaos;
                    uniform float u_speed;
                    uniform float u_hue;
                    uniform float u_intensity;
                    uniform float u_rot4dXW;
                    uniform float u_rot4dYW;
                    uniform float u_rot4dZW;
                    uniform float u_roleIntensity;
                    uniform float u_offsetY;

                    mat4 rotateXW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(c, 0.0, 0.0, -s, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, s, 0.0, 0.0, c);
                    }

                    mat4 rotateYW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c);
                    }

                    mat4 rotateZW(float theta) {
                        float c = cos(theta);
                        float s = sin(theta);
                        return mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c);
                    }

                    vec3 project4Dto3D(vec4 p) {
                        float w = 2.5 / (2.5 + p.w);
                        return vec3(p.x * w, p.y * w, p.z * w);
                    }

                    vec3 warpHypersphere(vec3 p) {
                        float radius = length(p);
                        float w = sin(radius * 1.5 + u_time * 0.0008 * u_speed) * 0.6;
                        vec4 p4d = vec4(p, w);
                        p4d = rotateXW(u_rot4dXW) * p4d;
                        p4d = rotateYW(u_rot4dYW) * p4d;
                        p4d = rotateZW(u_rot4dZW) * p4d;
                        return project4Dto3D(p4d);
                    }

                    float hypercubeLattice(vec3 p, float gridSize) {
                        vec3 grid = fract(p * gridSize);
                        vec3 edges = min(grid, 1.0 - grid);
                        float minEdge = min(min(edges.x, edges.y), edges.z);
                        return 1.0 - smoothstep(0.0, 0.03, minEdge);
                    }

                    float sphereLattice(vec3 p, float gridSize) {
                        vec3 cell = fract(p * gridSize) - 0.5;
                        return 1.0 - smoothstep(0.15, 0.25, length(cell));
                    }

                    float torusLattice(vec3 p, float gridSize) {
                        vec3 cell = fract(p * gridSize) - 0.5;
                        float toroidalDist = length(vec2(length(cell.xy) - 0.3, cell.z));
                        return 1.0 - smoothstep(0.08, 0.12, toroidalDist);
                    }

                    float waveLattice(vec3 p, float gridSize) {
                        float time = u_time * 0.001 * u_speed;
                        float wave = sin(p.x * gridSize * 2.0 + time * 2.0) +
                                   sin(p.y * gridSize * 1.8 + time * 1.5) +
                                   sin(p.z * gridSize * 2.2 + time * 1.8);
                        return max(0.0, wave / 3.0);
                    }

                    float geometryFunction(vec4 p) {
                        vec3 p3d = project4Dto3D(p);
                        vec3 warped = warpHypersphere(p3d);
                        float gridSize = u_gridDensity * 0.08;

                        int geomType = int(mod(u_geometry, 8.0));

                        if (geomType == 0) return hypercubeLattice(warped, gridSize);
                        else if (geomType == 1) return sphereLattice(warped, gridSize);
                        else if (geomType == 2) return torusLattice(warped, gridSize);
                        else if (geomType == 3) return waveLattice(warped, gridSize);
                        else return hypercubeLattice(warped, gridSize);
                    }

                    vec3 getLayerColor(int layerIndex, float hueShift) {
                        if (layerIndex == 0) return vec3(0.05, 0.0, 0.2);
                        else if (layerIndex == 1) return vec3(0.0, 0.3, 0.3);
                        else if (layerIndex == 2) return mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 1.0), hueShift);
                        else if (layerIndex == 3) return vec3(0.0, 1.0, 1.0);
                        else return vec3(1.0, 0.0, 1.0);
                    }

                    void main() {
                        vec2 uv = (gl_FragCoord.xy - u_resolution.xy * 0.5) / min(u_resolution.x, u_resolution.y);
                        uv.y += u_offsetY;

                        float timeSpeed = u_time * 0.0001 * u_speed;
                        vec4 pos = vec4(uv * 3.0, sin(timeSpeed * 3.0), cos(timeSpeed * 2.0));

                        pos = rotateXW(u_rot4dXW) * pos;
                        pos = rotateYW(u_rot4dYW) * pos;
                        pos = rotateZW(u_rot4dZW) * pos;

                        float value = geometryFunction(pos);
                        float noise = sin(pos.x * 7.0) * cos(pos.y * 11.0);
                        value += noise * u_chaos;

                        float geometryIntensity = 1.0 - clamp(abs(value * 0.8), 0.0, 1.0);
                        geometryIntensity = pow(geometryIntensity, 1.5);
                        float finalIntensity = geometryIntensity * u_intensity;

                        int layerIndex = u_roleIntensity == 0.4 ? 0 :
                                       u_roleIntensity == 0.6 ? 1 :
                                       u_roleIntensity == 1.0 ? 2 :
                                       u_roleIntensity == 1.3 ? 3 : 4;

                        vec3 layerColor = getLayerColor(layerIndex, u_hue);
                        vec3 finalColor = layerColor * finalIntensity;

                        float layerAlpha = u_roleIntensity == 1.0 ? 1.0 :
                                         u_roleIntensity == 1.3 ? 0.8 :
                                         u_roleIntensity == 1.6 ? 0.3 :
                                         u_roleIntensity == 0.6 ? 0.4 : 0.6;

                        gl_FragColor = vec4(finalColor, finalIntensity * layerAlpha);
                    }
                `;

                this.program = this.createProgram(vertexShader, fragmentShader);

                this.uniforms = {
                    resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                    time: this.gl.getUniformLocation(this.program, 'u_time'),
                    geometry: this.gl.getUniformLocation(this.program, 'u_geometry'),
                    gridDensity: this.gl.getUniformLocation(this.program, 'u_gridDensity'),
                    chaos: this.gl.getUniformLocation(this.program, 'u_chaos'),
                    speed: this.gl.getUniformLocation(this.program, 'u_speed'),
                    hue: this.gl.getUniformLocation(this.program, 'u_hue'),
                    intensity: this.gl.getUniformLocation(this.program, 'u_intensity'),
                    rot4dXW: this.gl.getUniformLocation(this.program, 'u_rot4dXW'),
                    rot4dYW: this.gl.getUniformLocation(this.program, 'u_rot4dYW'),
                    rot4dZW: this.gl.getUniformLocation(this.program, 'u_rot4dZW'),
                    roleIntensity: this.gl.getUniformLocation(this.program, 'u_roleIntensity'),
                    offsetY: this.gl.getUniformLocation(this.program, 'u_offsetY')
                };
            }

            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);

                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) return null;
                return program;
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) return null;
                return shader;
            }

            initBuffers() {
                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                this.buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
            }

            resize() {
                const dpr = Math.min(window.devicePixelRatio || 1, 2);
                this.canvas.width = this.canvas.clientWidth * dpr;
                this.canvas.height = this.canvas.clientHeight * dpr;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            updateParameters(params) {
                Object.assign(this.params, params);
            }

            render() {
                if (!this.program) return;

                this.gl.useProgram(this.program);
                this.gl.clearColor(0, 0, 0, 0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);

                const roleIntensities = {
                    'background': 0.4,
                    'shadow': 0.6,
                    'content': 1.0,
                    'highlight': 1.3,
                    'accent': 1.6
                };

                const time = Date.now() - this.startTime;

                this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                this.gl.uniform1f(this.uniforms.time, time);
                this.gl.uniform1f(this.uniforms.geometry, this.params.geometry);
                this.gl.uniform1f(this.uniforms.gridDensity, this.params.gridDensity);
                this.gl.uniform1f(this.uniforms.chaos, this.params.chaos);
                this.gl.uniform1f(this.uniforms.speed, this.params.speed);
                this.gl.uniform1f(this.uniforms.hue, this.params.hue);
                this.gl.uniform1f(this.uniforms.intensity, this.params.intensity);
                this.gl.uniform1f(this.uniforms.rot4dXW, this.params.rot4dXW);
                this.gl.uniform1f(this.uniforms.rot4dYW, this.params.rot4dYW);
                this.gl.uniform1f(this.uniforms.rot4dZW, this.params.rot4dZW);
                this.gl.uniform1f(this.uniforms.roleIntensity, roleIntensities[this.role] || 1.0);
                this.gl.uniform1f(this.uniforms.offsetY, this.params.offsetY);

                this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // ========== SCROLL CONTROLLER ==========
        class ScrollController {
            constructor() {
                this.currentSection = 0;
                this.currentTick = 0;
                this.ticksPerSection = 5;
                this.isTransitioning = false;
                this.scrollCooldown = false;

                this.morphCard = document.getElementById('morph-card');
                this.sectionContent = document.getElementById('section-content');
                this.scrollIndicator = document.getElementById('scroll-indicator');

                this.createProgressDots();
                this.loadSection(0);
                this.setupEventListeners();

                console.log('🎬 Scroll Controller Ready');
            }

            createProgressDots() {
                const container = document.getElementById('progress-dots');
                SECTIONS.forEach((_, i) => {
                    const dot = document.createElement('div');
                    dot.className = 'progress-dot' + (i === 0 ? ' active' : '');
                    dot.addEventListener('click', () => this.jumpToSection(i));
                    container.appendChild(dot);
                });
                this.progressDots = container.querySelectorAll('.progress-dot');
            }

            setupEventListeners() {
                document.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.handleScroll(e.deltaY);
                }, { passive: false });

                let touchStartY = 0;
                document.addEventListener('touchstart', (e) => {
                    touchStartY = e.touches[0].clientY;
                });

                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const delta = touchStartY - e.touches[0].clientY;
                    if (Math.abs(delta) > 30) {
                        this.handleScroll(delta);
                        touchStartY = e.touches[0].clientY;
                    }
                }, { passive: false });
            }

            handleScroll(delta) {
                if (this.scrollCooldown || this.isTransitioning) return;

                const direction = delta > 0 ? 1 : -1;
                this.currentTick += direction;

                this.scrollIndicator.classList.add('hidden');
                this.updatePerTickChoreography();

                if (this.currentTick >= this.ticksPerSection) {
                    if (this.currentSection < SECTIONS.length - 1) {
                        this.currentSection++;
                        this.currentTick = 0;
                        this.transitionToSection(this.currentSection);
                    } else {
                        this.currentTick = this.ticksPerSection - 1;
                    }
                } else if (this.currentTick < 0) {
                    if (this.currentSection > 0) {
                        this.currentSection--;
                        this.currentTick = this.ticksPerSection - 1;
                        this.transitionToSection(this.currentSection);
                    } else {
                        this.currentTick = 0;
                    }
                }

                this.updateDebug();
                this.scrollCooldown = true;
                setTimeout(() => this.scrollCooldown = false, 100);
            }

            updatePerTickChoreography() {
                const section = SECTIONS[this.currentSection];
                const progress = this.currentTick / (this.ticksPerSection - 1);

                // SMOOTH EASING FUNCTIONS FOR GRACEFUL CHOREOGRAPHY
                const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                const easeOutQuart = t => 1 - Math.pow(1 - t, 4);
                const easeInOutSine = t => -(Math.cos(Math.PI * t) - 1) / 2;

                const smoothProgress = easeInOutCubic(progress);
                const floatyProgress = easeInOutSine(progress);
                const dynamicProgress = easeOutQuart(progress);

                // UPDATE EACH LAYER INDEPENDENTLY WITH UNIQUE CHOREOGRAPHY
                window.quantumVisualizers.forEach(viz => {
                    const layerConfig = section.layers[viz.role];
                    if (!layerConfig) return;

                    // CALCULATE PROGRESSIVE PARAMETER EVOLUTION
                    const baseOffsetY = layerConfig.offsetY || 0;
                    const progressiveOffsetY = baseOffsetY + (floatyProgress * -0.5);

                    // DENSITY EVOLUTION WITH LAYER-SPECIFIC VARIANCE
                    const layerDensityMultiplier = {
                        'background': 0.7,
                        'shadow': 0.85,
                        'content': 1.0,
                        'highlight': 1.15,
                        'accent': 1.3
                    }[viz.role] || 1.0;

                    const densityDrop = progress * 8 * layerDensityMultiplier;
                    const progressiveGridDensity = Math.max(
                        layerConfig.gridDensity * 0.3,
                        layerConfig.gridDensity - densityDrop
                    );

                    // 4D ROTATION CHOREOGRAPHY - UNIQUE PER LAYER
                    const baseRot4dXW = layerConfig.rot4dXW || 0;
                    const baseRot4dYW = layerConfig.rot4dYW || 0;
                    const baseRot4dZW = layerConfig.rot4dZW || 0;

                    const rot4dXW = baseRot4dXW + (Math.sin(smoothProgress * Math.PI) * 0.4 * layerDensityMultiplier);
                    const rot4dYW = baseRot4dYW + (Math.cos(dynamicProgress * Math.PI * 0.7) * 0.3 * layerDensityMultiplier);
                    const rot4dZW = baseRot4dZW + (smoothProgress * 0.5 * layerDensityMultiplier);

                    // MORPH FACTOR EVOLUTION
                    const progressiveMorphFactor = layerConfig.morphFactor + (dynamicProgress * 0.3);

                    // DIMENSION EVOLUTION (3D → 4D+ HYPERCUBE)
                    const progressiveDimension = layerConfig.dimension + (smoothProgress * 0.5);

                    // ROTATION SPEED CHOREOGRAPHY
                    const progressiveRotationSpeed = layerConfig.rotationSpeed * (1.0 + floatyProgress * 0.4);

                    // PATTERN INTENSITY MODULATION
                    const progressivePatternIntensity = layerConfig.patternIntensity * (1.0 + progress * 0.3);

                    // GLITCH INTENSITY BUILDUP
                    const progressiveGlitchIntensity = layerConfig.glitchIntensity + (Math.pow(progress, 2) * 0.05);

                    // COLOR SHIFT EVOLUTION
                    const progressiveColorShift = layerConfig.colorShift + (Math.sin(progress * Math.PI) * 0.2);

                    // APPLY COMPLETE PARAMETER SET TO THIS LAYER
                    viz.updateParameters({
                        geometry: layerConfig.geometry,
                        gridDensity: progressiveGridDensity,
                        morphFactor: progressiveMorphFactor,
                        dimension: progressiveDimension,
                        rotationSpeed: progressiveRotationSpeed,
                        lineThickness: layerConfig.lineThickness,
                        patternIntensity: progressivePatternIntensity,
                        universeModifier: layerConfig.universeModifier,
                        glitchIntensity: progressiveGlitchIntensity,
                        colorShift: progressiveColorShift,
                        rot4dXW,
                        rot4dYW,
                        rot4dZW,
                        offsetY: progressiveOffsetY,
                        // Legacy compatibility
                        chaos: progressiveGlitchIntensity * 3.0,
                        speed: progressiveRotationSpeed,
                        intensity: progressivePatternIntensity,
                        hue: 0.556 + (progressiveColorShift * 0.1)
                    });
                });

                // CARD CHOREOGRAPHY
                this.updateCardChoreography(progress, smoothProgress);
            }

            updateCardChoreography(progress, smoothProgress) {
                const section = SECTIONS[this.currentSection];
                const cardStage = document.getElementById('card-stage');

                // CARD MORPHING WITH SMOOTH PROGRESS
                const cards = cardStage.querySelectorAll('.morph-card');

                cards.forEach((card, index) => {
                    // INDIVIDUAL CARD CHOREOGRAPHY
                    const cardDelay = index * 0.1;
                    const cardProgress = Math.max(0, Math.min(1, (progress - cardDelay) / (1 - cardDelay)));
                    const cardSmooth = Math.pow(cardProgress, 1.5);

                    // 3D TRANSFORM CHOREOGRAPHY
                    const rotateY = Math.sin(smoothProgress * Math.PI) * 15;
                    const rotateX = Math.cos(smoothProgress * Math.PI * 0.7) * 8;
                    const translateZ = cardSmooth * 50;
                    const scale = 1.0 + (Math.sin(cardProgress * Math.PI) * 0.05);

                    card.style.transform = `
                        perspective(2000px)
                        rotateY(${rotateY}deg)
                        rotateX(${rotateX}deg)
                        translateZ(${translateZ}px)
                        scale(${scale})
                    `;

                    // OPACITY PULSING
                    const opacityPulse = 0.9 + (Math.sin(progress * Math.PI * 2) * 0.1);
                    card.style.opacity = opacityPulse;

                    // BORDER GLOW INTENSITY
                    const glowIntensity = 0.2 + (smoothProgress * 0.3);
                    card.style.boxShadow = `
                        0 0 ${60 + smoothProgress * 40}px rgba(0, 255, 255, ${glowIntensity}),
                        inset 0 0 ${40 + smoothProgress * 20}px rgba(0, 255, 255, ${glowIntensity * 0.25})
                    `;
                });
            }

            transitionToSection(index) {
                this.isTransitioning = true;

                this.progressDots.forEach((dot, i) => {
                    dot.classList.toggle('active', i === index);
                });

                this.loadSection(index);

                // UPDATE EACH LAYER INDEPENDENTLY WITH NEW SECTION CONFIGURATION
                const section = SECTIONS[index];
                window.quantumVisualizers.forEach(viz => {
                    const layerConfig = section.layers[viz.role];
                    if (!layerConfig) return;

                    viz.updateParameters({
                        geometry: layerConfig.geometry,
                        gridDensity: layerConfig.gridDensity,
                        morphFactor: layerConfig.morphFactor,
                        dimension: layerConfig.dimension,
                        rotationSpeed: layerConfig.rotationSpeed,
                        lineThickness: layerConfig.lineThickness,
                        patternIntensity: layerConfig.patternIntensity,
                        universeModifier: layerConfig.universeModifier,
                        glitchIntensity: layerConfig.glitchIntensity,
                        colorShift: layerConfig.colorShift,
                        rot4dXW: layerConfig.rot4dXW || 0,
                        rot4dYW: layerConfig.rot4dYW || 0,
                        rot4dZW: layerConfig.rot4dZW || 0,
                        offsetY: 0.0,
                        // Legacy compatibility
                        chaos: layerConfig.glitchIntensity * 3.0,
                        speed: layerConfig.rotationSpeed,
                        intensity: layerConfig.patternIntensity,
                        hue: 0.556 + (layerConfig.colorShift * 0.1)
                    });
                });

                setTimeout(() => {
                    this.isTransitioning = false;
                }, 1200);
            }

            loadSection(index) {
                const section = SECTIONS[index];
                const cardStage = document.getElementById('card-stage');

                // FADE OUT CURRENT CARDS
                const currentCards = cardStage.querySelectorAll('.morph-card');
                currentCards.forEach(card => card.classList.remove('active'));

                setTimeout(() => {
                    // CONFIGURE CARD STAGE FOR SPLITTING
                    cardStage.className = 'card-stage';
                    if (section.cards && section.cards.count > 1) {
                        cardStage.classList.add(`split-${section.cards.count}`);
                    }

                    // CREATE CARDS
                    cardStage.innerHTML = '';
                    const cardCount = section.cards?.count || 1;

                    for (let i = 0; i < cardCount; i++) {
                        const card = document.createElement('div');
                        card.className = 'morph-card' + (i > 0 ? ' card-clone' : '');

                        // CARD BACKGROUND ACCENT
                        const accent = document.createElement('div');
                        accent.className = 'card-bg-accent';
                        card.appendChild(accent);

                        // CARD CONTENT
                        const content = document.createElement('div');
                        if (section.cards && section.cards.contents && section.cards.contents[i]) {
                            content.innerHTML = section.cards.contents[i];
                        } else {
                            content.innerHTML = section.content;
                        }
                        card.appendChild(content);

                        // APPLY CARD STYLES
                        if (section.cardStyle) {
                            Object.entries(section.cardStyle).forEach(([key, value]) => {
                                card.style.setProperty(key, value);
                            });
                        }

                        cardStage.appendChild(card);

                        // STAGGERED ACTIVATION
                        setTimeout(() => {
                            card.classList.add('active');
                        }, 50 + (i * 150));
                    }
                }, 300);

                // Store reference to first card for backwards compatibility
                setTimeout(() => {
                    this.morphCard = cardStage.querySelector('.morph-card');
                    this.sectionContent = this.morphCard?.querySelector('div:last-child');
                }, 350);
            }

            jumpToSection(index) {
                if (index === this.currentSection || this.isTransitioning) return;
                this.currentSection = index;
                this.currentTick = 0;
                this.transitionToSection(index);
            }

            updateDebug() {
                document.getElementById('debug-section').textContent = this.currentSection;
                document.getElementById('debug-ticks').textContent = `${this.currentTick} / ${this.ticksPerSection}`;

                if (window.quantumVisualizers && window.quantumVisualizers[0]) {
                    const viz = window.quantumVisualizers[0];
                    document.getElementById('debug-offset').textContent = viz.params.offsetY.toFixed(2);
                    document.getElementById('debug-density').textContent = viz.params.gridDensity.toFixed(1);
                    document.getElementById('debug-rot').textContent = viz.params.rot4dXW.toFixed(2);
                }
            }
        }

        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', () => {
            const layers = [
                { id: 'quantum-background', role: 'background', reactivity: 0.4 },
                { id: 'quantum-shadow', role: 'shadow', reactivity: 0.6 },
                { id: 'quantum-content', role: 'content', reactivity: 1.0 },
                { id: 'quantum-highlight', role: 'highlight', reactivity: 1.3 },
                { id: 'quantum-accent', role: 'accent', reactivity: 1.6 }
            ];

            window.quantumVisualizers = layers.map(layer => {
                const viz = new QuantumVisualizer(layer.id, layer.role, layer.reactivity);
                console.log(`✅ ${layer.role} visualizer created`);
                return viz;
            }).filter(viz => viz.gl);

            function renderLoop() {
                window.quantumVisualizers.forEach(viz => viz.render());
                requestAnimationFrame(renderLoop);
            }
            renderLoop();

            window.scrollController = new ScrollController();

            console.log('🚀 MINOOTS Experience Ready');
        });
    </script>
</body>
</html>

<!--
🌟 A Paul Phillips Manifestation
Paul@clearseassolutions.com | Parserator.com
© 2025 Clear Seas Solutions LLC
-->
